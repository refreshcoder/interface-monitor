<%+header%>
<style>
  .modern-card { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px; }
  .controls { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 20px; }
  .control-group { display: flex; flex-direction: column; gap: 5px; }
  .control-group label { font-size: 12px; font-weight: bold; color: #555; }
  select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #fff; min-width: 150px; }
  .btn-danger { background: #d32f2f; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: 500; margin-left: auto; }
  .btn-danger:hover { background: #b71c1c; }
  .chart-container { position: relative; height: 500px; width: 100%; margin-top: 20px; }
  .info-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px; }
  .info-card { background: #f5f5f5; padding: 10px; border-radius: 4px; font-size: 12px; border-left: 4px solid #1976d2; }
  .info-card h4 { margin: 0 0 5px 0; font-size: 14px; color: #333; }
  .info-card p { margin: 2px 0; color: #666; }
</style>

<h2><%:Connectivity Monitor%></h2>

<%
local fs = require "nixio.fs"
local log_dir = "/tmp/log/interface_monitor"
local files = {}
for f in fs.dir(log_dir) do
    if f:match("^conn_.*\\.log$") then
        table.insert(files, f)
    end
end
table.sort(files, function(a,b) return a > b end)
local current_file = http.formvalue("file") or files[1]
%>

<script src="<%=resource%>/interface-monitor/echarts.min.js"></script>

<div class="cbi-section">
  <div class="modern-card">
    <form method="get" action="<%=luci.dispatcher.build_url('admin/status/interface_monitor/graph')%>" id="filterForm">
      <div class="controls">
        <div class="control-group">
          <label><%:Log File%></label>
          <select name="file" onchange="this.form.submit()">
            <% for _,f in ipairs(files) do %>
              <option value="<%=f%>" <%=f==current_file and "selected" or ""%>><%=f%></option>
            <% end %>
          </select>
        </div>
        <div class="control-group">
          <label><%:Time Range%></label>
          <select name="range" id="rangeSelect" onchange="updateChart()">
            <option value="60">Last 1 Hour</option>
            <option value="360">Last 6 Hours</option>
            <option value="1440" selected>Last 24 Hours</option>
            <option value="0">All Data</option>
          </select>
        </div>
        <button type="button" class="btn-danger" onclick="clearHistory()"><%:Clear History%></button>
      </div>
    </form>

    <% if current_file then %>
    <div id="deviceInfo" class="info-grid"></div>
    <div class="chart-container" id="chart"></div>
    <% else %>
    <p><%:No connectivity log found. Check if the service is running and configured.%></p>
    <% end %>
  </div>
</div>

<script type="text/javascript">
  var rpc = require('luci.rpc');
  var chartInstance = null;
  var rawData = [];

  function fetchDataAndRender() {
    var file = '<%=current_file%>';
    if (!file) {
      document.getElementById('chart').innerHTML = '<p><%:No log file selected or available.%></p>';
      return;
    }

    rpc.call('admin.interface_monitor', 'get_log_data', { file: file }, function(data) {
      if (data) {
        rawData = data;
        document.addEventListener('DOMContentLoaded', function() {
          if (window.echarts) {
            chartInstance = echarts.init(document.getElementById('chart'));
            updateChart();
          } else {
            console.error('ECharts library not loaded.');
          }
        });
      } else {
        document.getElementById('chart').innerHTML = '<p><%:Failed to load log data.%></p>';
      }
    });
  }

  function parseData() {
    if (!rawData) return {};

    var dataMap = {}; // ip -> { points: [], info: {} }

    for (var i = 0; i < rawData.length; i++) {
      var line = rawData[i].trim();
      if (!line) continue;

      var parts = line.split('|');
      // Format: Timestamp|IP|Status|Loss|RTT|Interface|MAC|Hostname|PhyInterface
      if (parts.length < 5) continue;

      var ts = parts[0];
      var ip = parts[1];
      var status = parts[2];
      var loss = parseFloat(parts[3]) || 0;
      var rtt = parseFloat(parts[4]) || 0;
      var iface = parts[5] || 'unknown';
      var mac = parts[6] || 'unknown';
      var hostname = parts[7] || 'unknown';
      var phy = parts[8] || iface; // Fallback to logical if phy not found

      if (!dataMap[ip]) {
        dataMap[ip] = { points: [], info: { ip: ip, mac: mac, hostname: hostname, iface: iface, phy: phy, up: 0, total: 0 } };
      }

      // Update latest info
      if (mac !== 'unknown') dataMap[ip].info.mac = mac;
      if (hostname !== 'unknown') dataMap[ip].info.hostname = hostname;
      if (phy !== 'unknown') dataMap[ip].info.phy = phy;
      
      dataMap[ip].info.total++;
      if (status === 'up') dataMap[ip].info.up++;

      dataMap[ip].points.push({
        value: [ts, rtt],
        loss: loss,
        status: status,
        info: dataMap[ip].info // Reference to current info state
      });
    }
    return dataMap;
  }

  fetchDataAndRender();

  function updateChart() {
    var range = parseInt(document.getElementById('rangeSelect').value);
    var dataMap = parseData();
    var seriesList = [];
    var legendData = [];
    var infoHtml = '';
    
    // Filter by range
    var now = new Date();
    // If we have data, use the last data point as 'now' to ensure we see something if logs are old
    // Actually, user wants 'Last N Hours', usually relative to 'now' (real time) or 'log end time'.
    // Let's use real time for live monitoring, but if looking at old logs, it might be empty.
    // Let's find the max timestamp in data to be safe?
    // No, standard practice is relative to now, but let's check if the file is today.
    // The file name is conn_YYYY-MM-DD.log.
    
    var cutoff = new Date(now.getTime() - range * 60 * 1000);

    Object.keys(dataMap).forEach(function(ip) {
      var entry = dataMap[ip];
      var points = entry.points;
      
      if (range > 0) {
        points = points.filter(function(p) {
          return new Date(p.value[0].replace(' ', 'T')) >= cutoff;
        });
      }
      
      if (points.length === 0) return;

      legendData.push(ip);
      
      // Calculate availability
      var avail = (entry.info.total > 0) ? (entry.info.up / entry.info.total * 100).toFixed(1) : 0;
      var color = getColor(ip);
      
      // Info Card
      infoHtml += '<div class="info-card" style="border-left-color: ' + color + '">';
      infoHtml += '<h4>' + ip + ' <small>(' + avail + '% Avail)</small></h4>';
      infoHtml += '<p><strong>Host:</strong> ' + entry.info.hostname + '</p>';
      infoHtml += '<p><strong>MAC:</strong> ' + entry.info.mac + '</p>';
      infoHtml += '<p><strong>Iface:</strong> ' + entry.info.iface + (entry.info.phy !== entry.info.iface ? ' (' + entry.info.phy + ')' : '') + '</p>';
      infoHtml += '</div>';

      seriesList.push({
        name: ip,
        type: 'line',
        showSymbol: false,
        data: points,
        smooth: true,
        lineStyle: { width: 2 },
        itemStyle: { color: color },
        emphasis: { focus: 'series' },
        markPoint: {
          data: points.filter(p => p.loss > 0 || p.status === 'down').map(p => ({
             coord: p.value,
             value: p.loss + '%',
             itemStyle: { color: '#d32f2f' }
          })),
          symbolSize: 30
        }
      });
    });

    document.getElementById('deviceInfo').innerHTML = infoHtml;

    if (!chartInstance) {
      chartInstance = echarts.init(document.getElementById('chart'));
    }

    var option = {
      tooltip: {
        trigger: 'axis',
        formatter: function(params) {
          var res = params[0].axisValueLabel + '<br/>';
          params.forEach(function(item) {
             var d = item.data;
             res += '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + item.color + '"></span>';
             res += '<strong>' + item.seriesName + '</strong>: ' + d.value[1] + 'ms (Loss: ' + d.loss + '%)<br/>';
          });
          return res;
        }
      },
      legend: {
        data: legendData,
        bottom: 0
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '10%',
        containLabel: true
      },
      xAxis: {
        type: 'time',
        boundaryGap: false
      },
      yAxis: {
        type: 'value',
        name: 'Latency (ms)',
        splitLine: {
          lineStyle: { type: 'dashed' }
        }
      },
      dataZoom: [
        { type: 'inside', start: 0, end: 100 },
        { type: 'slider', start: 0, end: 100 }
      ],
      series: seriesList
    };

    chartInstance.setOption(option, true); // true = not merge, replace
  }

  // Simple color hash
  function getColor(str) {
    var colors = ['#1976d2', '#388e3c', '#fbc02d', '#7b1fa2', '#0288d1', '#e64a19', '#5d4037', '#c2185b'];
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  }

  function clearHistory() {
    if (confirm('<%:Are you sure you want to delete all logs?%>')) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', '<%=luci.dispatcher.build_url("admin/status/interface_monitor/clear_logs")%>', true);
      xhr.onload = function() {
        if (xhr.status === 200) {
          alert('<%:Logs cleared successfully%>');
          location.reload();
        } else {
          alert('<%:Failed to clear logs%>');
        }
      };
      xhr.send();
    }
  }

  // Init
  if (document.getElementById('raw')) {
    var waited = 0;
    (function waitECharts(){
      if (typeof echarts !== 'undefined') {
        updateChart();
      } else {
        waited += 200;
        if (waited > 5000) {
          var chartEl = document.getElementById('chart');
          if (chartEl) chartEl.innerHTML = '<div style="color:#d32f2f">无法加载图表库，请检查网络或离线资源。</div>';
          return;
        }
        setTimeout(waitECharts, 200);
      }
    })();
    window.addEventListener('resize', function() {
      if(chartInstance) chartInstance.resize();
    });
  }
</script>
<%+footer%>
